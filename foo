#------------------------------------------------------------	#------------------------------------------------------------
# 1-2/2D Darwin OpenMP PIC code					# 1-2/2D Darwin OpenMP PIC code
# written by Viktor K. Decyk and Joshua Kelly, UCLA		# written by Viktor K. Decyk and Joshua Kelly, UCLA
# copyright 2016, regents of the university of california	# copyright 2016, regents of the university of california
import sys							import sys
import math							import math
import numpy							import numpy

sys.path.append('./mbeps1.source')				sys.path.append('./mbeps1.source')
from libmpush1 import *						from libmpush1 import *
from libmbpush1 import *					from libmbpush1 import *
from libmdpush1 import *					from libmdpush1 import *
from fomplib import *						from fomplib import *
from fgraf1 import *						from fgraf1 import *
from dtimer import *						from dtimer import *

							      >	"""
							      >	This imports the gui code
							      >	"""
							      >	from types import *  #This is required for the rightType func
							      >	import sys
							      >	sys.path.append('./gui')
							      >	from ProceduralInterface import *
							      >
							      >	int_type = numpy.int32
							      >	double_type = numpy.float64
							      >	float_type = numpy.float32
							      >	complex_type = numpy.complex64
							      >
							      >	#Some boilderplate
							      >	def changeVarsCallback(obj, to):
							      >	   for key in to.var:
							      >	      setattr(obj, key, rightType(to.var[key]) )
							      >
							      >	def rightType(val):
							      >	   ints, reals, complexs = int_type, float_type, complex_type
							      >	   if type(val) is IntType:
							      >	      return numpy.array([val], ints)
							      >	   elif type(val) is FloatType:
							      >	      return numpy.array([val],reals)
							      >	   elif type(val) is ComplexType:
							      >	      return numpy.array([val], complexs)
							      >
							      >	"""
							      >	Define function that initializes menus
							      >	"""
							      >	def initialize_menus(pc, defaultGraphs):
							      >	# initialize all diagnostics from namelist input parameters
							      >	# initialize energy diagnostic: allocates wt
							      >	   if (in1.ntw > 0):
							      >	      pc.addGraph("ENERGY", "Energy") #Enable electron veloci
							      >	      defaultGraphs.append("ENERGY")
							      >
							      >	   if in1.nts > 0:
							      >	      labels = ["Vx-x Phase Plot","Vy-x Phase Plot","Vz-x Pha
							      >	      nn = in1.nsxv
							      >	      for i in xrange(0,3):
							      >	         if ((nn % 2)==1):
							      >	            pc.addGraph("EPHASE"+str(i), "Electron/"+labels[i
							      >	            defaultGraphs.append("EPHASE"+str(i))
							      >	            if (in1.movion==1): #Ions
							      >	               if ((in1.nds==2) or (in1.nds==3)):
							      >	                  pc.addGraph("IPHASE"+str(i), "Ions/"+labels
							      >	                  defaultGraphs.append("IPHASE"+str(i))
							      >	         nn = int(nn/2)
							      >	      #vx-vy, vx-vz or vy-vz
							      >	      labels = ["Vx-Vy Phase Plot","Vx-Vz Phase Plot","Vy-Vz 
							      >	      nn = in1.nsvv
							      >	      for i in xrange(0,3):
							      >	         if ((nn % 2)==1):
							      >	            pc.addGraph("EPHASEV"+str(i), "Electron/"+labels[
							      >	            defaultGraphs.append("EPHASEV"+str(i))
							      >	            if (in1.movion==1): #Ions
							      >	               if ((in1.nds==2) or (in1.nds==3)):
							      >	                  pc.addGraph("IPHASEV"+str(i), "Ions/"+label
							      >	                  defaultGraphs.append("IPHASEV"+str(i))
							      >	         nn = int(nn/2)
							      >
							      >	# initialize electron density diagnostic
							      >	   if (in1.ntde > 0):
							      >	      pc.addGraph("EDENSITY", "Density/Electron Density") #En
							      >	      defaultGraphs.append("EDENSITY")
							      >
							      >	# initialize ion density diagnostic: allocates pkwdi, wkdi
							      >	   if (in1.movion==1):
							      >	      if (in1.ntdi > 0):
							      >	         pc.addGraph("IDENSITY", "Density/Ion Density") #Enab
							      >	         defaultGraphs.append("IDENSITY")
							      >	         pc.addGraph("ION DENSITY OMEGA VS MODE+", "Ion Dispe
							      >	         pc.addGraph("ION DENSITY OMEGA VS MODE-", "Ion Dispe
							      >	         pc.addGraph("ION DENSITY OMEGA VS MODE LINE", "Ion D
							      >
							      >	         pc.addGraph("ION CURRENT OMEGA VS MODEY+", "Ion Disp
							      >	         pc.addGraph("ION CURRENT OMEGA VS MODEZ+", "Ion Disp
							      >	         pc.addGraph("ION CURRENT OMEGA VS MODEY-", "Ion Disp
							      >	         pc.addGraph("ION CURRENT OMEGA VS MODEZ-", "Ion Disp
							      >
							      >	# initialize potential diagnostic: allocates pkw, wk
							      >	   if (in1.ntp > 0):
							      >	      pc.addGraph("DRAWPOT", "Potential/Potential") #Enable e
							      >	      pc.addGraph("POTENTIAL OMEGA VS MODE+", "Potential/Pote
							      >	      pc.addGraph("POTENTIAL OMEGA VS MODE-", "Potential/Pote
							      >	      pc.addGraph("POTENTIAL OMEGA VS MODE LINE", "Potential/
							      >	      defaultGraphs.append("DRAWPOT")
							      >
							      >	# initialize longitudinal efield diagnostic
							      >	   if (in1.ntel > 0):
							      >	      pc.addGraph("ELFIELD", "E-Field/Longitudinal E-Field")
							      >	      defaultGraphs.append("ELFIELD")
							      >
							      >	# initialize ion current density diagnostic: allocates vpkwji
							      >	   if (in1.movion==1):
							      >	      if (in1.ntji > 0):
							      >	         pc.addGraph("ICURRENTD", "Ions/Ion Current Density")
							      >	         defaultGraphs.append("ICURRENTD")
							      >
							      >	# initialize darwin vector potential diagnostic: allocates vp
							      >	   if (in1.nta > 0):
							      >	      if ((in1.nda==1) or (in1.nda==3)):
							      >	         pc.addGraph("VECPOTENTIAL", "Vector Potential Diagno
							      >	         defaultGraphs.append("VECPOTENTIAL")
							      >	      pc.addGraph("VECTOR POTENTIAL OMEGA VS MODE Y+", "Vecto
							      >	      pc.addGraph("VECTOR POTENTIAL OMEGA VS MODE Y-", "Vecto
							      >	      pc.addGraph("VECTOR POTENTIAL OMEGA VS MODE Z+", "Vecto
							      >	      pc.addGraph("VECTOR POTENTIAL OMEGA VS MODE Z-", "Vecto
							      >
							      >	      pc.addGraph("VECTOR POTENTIAL OMEGA VS MODE Y LINE", "V
							      >	      pc.addGraph("VECTOR POTENTIAL OMEGA VS MODE Z LINE", "V
							      >	      
							      >	# initialize darwin transverse efield diagnostic:
							      >	# allocates vpkwet, vwket
							      >	   if (in1.ntet > 0):
							      >	      pc.addGraph("TRANSVERSE E FIELD", "Transverse Electric 
							      >	      defaultGraphs.append("TRANSVERSE E FIELD")
							      >	      pc.addGraph("TRANSVERSE E.F. Y OMEGA VS MODE", "Transve
							      >	      pc.addGraph("TRANSVERSE E.F. Z OMEGA VS MODE", "Transve
							      >
							      >	      pc.addGraph("FT TRANSVERSE E.F. Y +OMEGA VS MODE", "Tra
							      >	      pc.addGraph("FT TRANSVERSE E.F. Y -OMEGA VS MODE", "Tra
							      >	      pc.addGraph("FT TRANSVERSE E.F. Z +OMEGA VS MODE", "Tra
							      >	      pc.addGraph("FT TRANSVERSE E.F. Z -OMEGA VS MODE", "Tra
							      >
							      >	# initialize darwin magnetic field diagnostic
							      >	   if (in1.ntb > 0):
							      >	      pc.addGraph("BFIELD", "Magnetic Field") #Enable electro
							      >	      defaultGraphs.append("BFIELD")
							      >
							      >	# initialize velocity diagnostic
							      >	   if (in1.ntv > 0):
							      >	# electrons: allocates fv, fvm, fvtm
							      >	      pc.addGraph("EVELOCITY", "Electron Velocity") #Enable e
							      >	      defaultGraphs.append("EVELOCITY")
							      >	# ions: allocates fvi, fvmi, fvtmi
							      >	      if (in1.movion==1):
							      >	         pc.addGraph("IVELOCITY", "Ions/Ion Velocity") #Enabl
							      >	         defaultGraphs.append("IVELOCITY")
							      >
							      >	# initialize trajectory diagnostic: allocates partd, fvtp, fv
							      >	   if (in1.ntt > 0):
							      >	      pc.addGraph("TRAJECTORY", "Particle Trajectory") #Enabl
							      >	      defaultGraphs.append("TRAJECTORY")
							      >
							      >
							      >	#init GUI
							      >	pc = PlasmaContext()  #Create GUI
							      >	pc.showGraphs(True)   #enable graphics.  Setting to false wil
							      >	pc.asyncMode(0)     #Run in synchornos mode.
							      >	pc.clearGraphList()  #remove all default graph options
							      >	pc.callbacks["VARCHANGE"] = changeVarsCallback  #Set a callba
							      >	defaultGraphs = []
							      >
# override default input data					# override default input data
in1.emf = 2							in1.emf = 2
# read namelist							# read namelist
iuin = 8							iuin = 8
in1.readnml1(iuin)						in1.readnml1(iuin)
# override input data						# override input data
in1.idcode = 3							in1.idcode = 3
in1.ndim = 3							in1.ndim = 3
in1.ntar = 0							in1.ntar = 0

# import modules after namelist has been read			# import modules after namelist has been read
import s1							import s1
import sb1							import sb1
import sd1							import sd1

int_type = numpy.int32					      <
double_type = numpy.float64				      <
float_type = numpy.float32				      <
complex_type = numpy.complex64				      <
							      <
# ipbc = particle boundary condition: 1 = periodic		# ipbc = particle boundary condition: 1 = periodic
ipbc = sd1.ipbc							ipbc = sd1.ipbc
zero = 0.0							zero = 0.0

# declare scalars for standard code				# declare scalars for standard code
npi = 0								npi = 0
ws = numpy.zeros((1),float_type)				ws = numpy.zeros((1),float_type)
wpmax = numpy.empty((1),float_type)				wpmax = numpy.empty((1),float_type)
wpmin = numpy.empty((1),float_type)				wpmin = numpy.empty((1),float_type)

# declare scalars for OpenMP code				# declare scalars for OpenMP code
irc = numpy.zeros((1),int_type)					irc = numpy.zeros((1),int_type)
ierr = numpy.zeros((1),int_type)				ierr = numpy.zeros((1),int_type)

							      >	# declare scalars for diagnostics
							      >	iudm = 19
							      >	iude = 10; iup = 11; iuel = 12
							      >	iua = 13; iuet = 14; iub = 15
							      >	iudi = 20; iuji = 21
							      >
# declare and initialize timing data				# declare and initialize timing data
tinit = 0.0; tloop = 0.0					tinit = 0.0; tloop = 0.0
itime = numpy.empty((4),numpy.int32)				itime = numpy.empty((4),numpy.int32)
ltime = numpy.empty((4),numpy.int32)				ltime = numpy.empty((4),numpy.int32)
dtime = numpy.empty((1),double_type)				dtime = numpy.empty((1),double_type)

# start timing initialization					# start timing initialization
dtimer(dtime,itime,-1)						dtimer(dtime,itime,-1)

# text output file						# text output file
fname = "output1." + s1.cdrun					fname = "output1." + s1.cdrun
iuot = open(fname,"w")						iuot = open(fname,"w")

# in1.nvp = number of shared memory nodes (0=default)		# in1.nvp = number of shared memory nodes (0=default)
#nvp = int(input("enter number of nodes: "))			#nvp = int(input("enter number of nodes: "))
# initialize for shared memory parallel processing		# initialize for shared memory parallel processing
omplib.init_omp(in1.nvp)					omplib.init_omp(in1.nvp)

# open graphics device						# open graphics device
irc[0] = graf1.open_graphs(in1.nplot)				irc[0] = graf1.open_graphs(in1.nplot)

# initialize scalars for standard code				# initialize scalars for standard code
# np = total number of particles in simulation			# np = total number of particles in simulation
np = s1.np							np = s1.np
# nx = number of grid points in x direction			# nx = number of grid points in x direction
nx = s1.nx; nxh = int(nx/2)					nx = s1.nx; nxh = int(nx/2)
# npi = total number of ions in simulation			# npi = total number of ions in simulation
if (in1.movion > 0):						if (in1.movion > 0):
   npi = s1.npi							   npi = s1.npi
nxe = nx + 2; nxeh = int(nxe/2)					nxe = nx + 2; nxeh = int(nxe/2)
# nloop = number of time steps in simulation			# nloop = number of time steps in simulation
# nstart = initial time loop index			      <
# ntime = current time step					# ntime = current time step
nloop = s1.nloop; nstart = 0; ntime = 0			      |	nloop = s1.nloop; ntime = 0

# allocate field data for standard code:			# allocate field data for standard code:
# qe/qi = electron/ion charge density with guard cells	      |	# cue, fxyze, byze, eyz, byz, qe, qi, fxe, ffc, mixup, sct
# fxe = smoothed electric field with guard cells	      |	# dcu, cus, amu, exyze, ffe
# ffc = form factor array for poisson solver		      <
# mixup = bit reverse table for FFT			      <
# sct = sine/cosine table for FFT			      <
# cue = electron current density with guard cells	      <
# fxyze/byze = smoothed electric/magnetic field with guard ce <
# dcu/dcui = electron/ion acceleration density with guard cel <
# amu/amui = electron/ion momentum flux with guard cells      <
# cus = transverse electric field			      <
# ffe = form factor array for iterative poisson solver	      <
sd1.init_dfields13()						sd1.init_dfields13()

# prepare fft tables						# prepare fft tables
mfft1.mfft1_init(s1.mixup,s1.sct,in1.indx)			mfft1.mfft1_init(s1.mixup,s1.sct,in1.indx)
# calculate form factor: ffc					# calculate form factor: ffc
mfield1.mpois1_init(s1.ffc,in1.ax,s1.affp,nx)			mfield1.mpois1_init(s1.ffc,in1.ax,s1.affp,nx)
# initialize different ensemble of random numbers		# initialize different ensemble of random numbers
if (in1.nextrand > 0):						if (in1.nextrand > 0):
   minit1.mnextran1(in1.nextrand,in1.ndim,np+npi)		   minit1.mnextran1(in1.nextrand,in1.ndim,np+npi)

# open reset and restart files; iur, iurr, iur0		      <
s1.open_restart1()					      <
							      <
# new start						      <
if (in1.nustrt==1):					      <
# initialize electrons: updates ppart, kpic			# initialize electrons: updates ppart, kpic
# ppart = tiled electron particle arrays		      |	sb1.init_electrons13()
# kpic = number of electrons in each tile		      <
   sb1.init_electrons13()				      <

# initialize background charge density: updates qi		# initialize background charge density: updates qi
   if (in1.movion==0):					      |	if (in1.movion==0):
      s1.qi.fill(0.0)					      |	   s1.qi.fill(0.0)
      qmi = -in1.qme					      |	   qmi = -in1.qme
      mpush1.mpost1(s1.ppart,s1.qi,s1.kpic,qmi,s1.tdpost,in1. |	   mpush1.mpost1(sb1.ppart,s1.qi,sb1.kpic,qmi,s1.tdpost,in1.m
      mgard1.maguard1(s1.qi,s1.tguard,nx)		      |	   mgard1.maguard1(s1.qi,s1.tguard,nx)
							      |
# calculate shift constant for iteration: update wpm, q2m0    |	# find maximum and minimum initial electron density
   sd1.calc_shift13(iuot)				      |	s1.qe.fill(0.0)
							      |	mpush1.mpost1(sb1.ppart,s1.qe,sb1.kpic,in1.qme,s1.tdpost,in1.
# initialize ions:  updates pparti, kipic, cui		      |	mgard1.maguard1(s1.qe,s1.tguard,nx)
# pparti = tiled on particle arrays			      |	mdpush1.mfwpminx1(s1.qe,s1.qbme,wpmax,wpmin,nx)
# kipic = number of ions in each tile			      |	wpm = 0.5*(wpmax[0] + wpmin[0])*s1.affp
# cui = ion current density with guard cells		      |	# accelerate convergence: update wpm
   if (in1.movion==1):					      |	if (wpm <= 10.0):
      sb1.init_ions13()					      |	   wpm = 0.75*wpm
							      |	print >> iuot, "wpm=",wpm
# initialize darwin electric field			      |	q2m0 = wpm/s1.affp
   sd1.cus.fill(0.0)					      <
							      <
# restart to continue a run which was interrupted	      <
elif (in1.nustrt==2):					      <
   sd1.bread_drestart13(s1.iur)				      <
   ntime = s1.ntime					      <
   nstart = ntime					      <
# start a new run with data from a previous run		      <
elif (in1.nustrt==0):					      <
   sd1.bread_drestart13(s1.iur0)			      <
							      <
# calculate form factor: ffe					# calculate form factor: ffe
mfield1.mepois1_init(sd1.ffe,in1.ax,s1.affp,sd1.wpm,in1.ci,nx |	mfield1.mepois1_init(sd1.ffe,in1.ax,s1.affp,wpm,in1.ci,nx)

# initialize longitudinal electric field		      |	# initialize ions:  updates pparti, kipic 
s1.fxe.fill(0.0)					      |	if (in1.movion==1):
							      >	   sb1.init_ions13()
							      >
							      >	# initialize electric fields
							      >	sd1.cus.fill(0.0); s1.fxe.fill(0.0)

# set magnitude of external transverse magnetic field		# set magnitude of external transverse magnetic field
omt = numpy.sqrt(in1.omy*in1.omy + in1.omz*in1.omz)		omt = numpy.sqrt(in1.omy*in1.omy + in1.omz*in1.omz)

# reverse simulation at end back to start			# reverse simulation at end back to start
if (in1.treverse==1):						if (in1.treverse==1):
   nloop = 2*nloop						   nloop = 2*nloop
   sb1.nloop = nloop						   sb1.nloop = nloop
   sd1.nloop = nloop						   sd1.nloop = nloop

# initialize all diagnostics from namelist input parameters	# initialize all diagnostics from namelist input parameters
# wt = energy time history array=			      |	sd1.initialize_ddiagnostics13()
# pkw = power spectrum for potential			      |	initialize_menus(pc,defaultGraphs)
# pkwdi = power spectrum for ion density		      <
# wk = maximum frequency as a function of k for potential     <
# wkdi = maximum frequency as a function of k for ion density <
# fv/fvi = global electron/ion velocity distribution function <
# fvm/fvmi = electron/ion vdrift, vth, entropy for global dis <
# fvtm/fvtmi = time history of electron/ion vdrift, vth, and  <
# fvtp = velocity distribution function for test particles    <
# fvmtp = vdrift, vth, and entropy for test particles	      <
# partd = trajectory time history array			      <
# vpkwji = power spectrum for ion current density	      <
# vwkji = maximum frequency as a function of k for ion curren <
# vpkw = power spectrum for vector potential		      <
# vwk = maximum frequency as a function of k for vector poten <
# vpkwet = power spectrum for transverse efield		      <
# vwket = maximum frequency as a function of k for transverse <
sd1.initialize_ddiagnostics13(ntime)			      <
							      <
# read in restart diagnostic file to continue interrupted run <
if (in1.nustrt==2):					      <
   sd1.dread_drestart13(s1.iur)				      <
							      <
# write reset file					      <
sd1.bwrite_drestart13(s1.iurr,ntime)			      <

# initialization time						# initialization time
dtimer(dtime,itime,1)						dtimer(dtime,itime,1)
tinit = tinit + float(dtime)					tinit = tinit + float(dtime)
# start timing loop						# start timing loop
dtimer(dtime,ltime,-1)						dtimer(dtime,ltime,-1)

print >> iuot, "program mdbeps1"				print >> iuot, "program mdbeps1"

							      >	"""
							      >	Initialize default windows
							      >	"""
							      >	newwin = in1.nplot / 4  #Number of new 4 chart windows to mak
							      >	remplt = in1.nplot % 4
							      >
							      >	print in1.nplot
							      >
							      >	for i in range(newwin): #Create 4 graph windows
							      >	   tmpl = defaultGraphs[0:4]
							      >	   defaultGraphs = defaultGraphs[4:]
							      >	   pc.newFrame("Layout4", tmpl)
							      >	if remplt > 0: #Create smaller window
							      >	   lon = "Layout"
							      >	   if remplt == 2:
							      >	      lon = lon + "2v"
							      >	   else:
							      >	      lon = lon + str(remplt)
							      >	   pc.newFrame(lon,defaultGraphs)
							      >
# * * * start main iteration loop * * *				# * * * start main iteration loop * * *

for ntime in xrange(nstart,nloop):			      |	for ntime in xrange(0,nloop):
   print >> iuot, "ntime = ", ntime				   print >> iuot, "ntime = ", ntime
							      |	   """ 
# debug reset						      |	   The following 4 lines process events from the GUI.
#  if (ntime==nloop/2):					      |	   Nothing will happen without calling getEvents
#     sd1.bread_drestart13(s1.iurr)			      |	   """
#     sd1.reset_ddiags13()				      |	   curtime = ntime*in1.dt
							      >	   pc.setTime(curtime)
							      >	   pc.getEvents(in1)
							      >	   pc.fastForward(curtime, in1)

# deposit current with OpenMP: updates cue			# deposit current with OpenMP: updates cue
   dtimer(dtime,itime,-1)					   dtimer(dtime,itime,-1)
   sb1.cue.fill(0.0)						   sb1.cue.fill(0.0)
   dtimer(dtime,itime,1)					   dtimer(dtime,itime,1)
   sb1.tdjpost[0] += float(dtime)				   sb1.tdjpost[0] += float(dtime)
   mcurd1.wmdjpost1(s1.ppart,sb1.cue,s1.kpic,s1.ncl,s1.ihole, |	   mcurd1.wmdjpost1(sb1.ppart,sb1.cue,sb1.kpic,sb1.ncl,sb1.ih
                    zero,in1.ci,sb1.tdjpost,nx,in1.mx,ipbc,   |	                    in1.qme,zero,in1.ci,sb1.tdjpost,nx,in1.mx
                    in1.relativity,False,irc)			                    in1.relativity,False,irc)
# add guard cells: updates cue					# add guard cells: updates cue
   mgard1.macguard1(sb1.cue,sb1.tguard,nx)			   mgard1.macguard1(sb1.cue,sb1.tguard,nx)

# deposit ion current with OpenMP: updates cui			# deposit ion current with OpenMP: updates cui
   if (in1.movion==1):						   if (in1.movion==1):
      dtimer(dtime,itime,-1)					      dtimer(dtime,itime,-1)
      sb1.cui.fill(0.0)						      sb1.cui.fill(0.0)
      dtimer(dtime,itime,1)					      dtimer(dtime,itime,1)
      sb1.tdjpost[0] += float(dtime)				      sb1.tdjpost[0] += float(dtime)
      mcurd1.wmdjpost1(s1.pparti,sb1.cui,s1.kipic,s1.ncl,s1.i |	      mcurd1.wmdjpost1(sb1.pparti,sb1.cui,sb1.kipic,sb1.ncl,s
                       in1.qmi,zero,in1.ci,sb1.tdjpost,nx,in1	                       in1.qmi,zero,in1.ci,sb1.tdjpost,nx,in1
                       in1.relativity,list,irc)			                       in1.relativity,list,irc)
# add guard cells: updates cui					# add guard cells: updates cui
      mgard1.macguard1(sb1.cui,sb1.tguard,nx)			      mgard1.macguard1(sb1.cui,sb1.tguard,nx)

# deposit charge with OpenMP: updates qe			# deposit charge with OpenMP: updates qe
   dtimer(dtime,itime,-1)					   dtimer(dtime,itime,-1)
   s1.qe.fill(0.0)						   s1.qe.fill(0.0)
   dtimer(dtime,itime,1)					   dtimer(dtime,itime,1)
   s1.tdpost[0] += float(dtime)					   s1.tdpost[0] += float(dtime)
   mpush1.mpost1(s1.ppart,s1.qe,s1.kpic,in1.qme,s1.tdpost,in1 |	   mpush1.mpost1(sb1.ppart,s1.qe,sb1.kpic,in1.qme,s1.tdpost,i
# add guard cells: updates qe					# add guard cells: updates qe
   mgard1.maguard1(s1.qe,s1.tguard,nx)				   mgard1.maguard1(s1.qe,s1.tguard,nx)

# electron density diagnostic: updates sfield			# electron density diagnostic: updates sfield
   if (in1.ntde > 0):						   if (in1.ntde > 0):
      it = int(ntime/in1.ntde)					      it = int(ntime/in1.ntde)
      if (ntime==in1.ntde*it):					      if (ntime==in1.ntde*it):
         s1.edensity_diag1(s1.sfield)				         s1.edensity_diag1(s1.sfield)
# display smoothed electron density				# display smoothed electron density
							      >	         edenx = numpy.array(range(nx))
							      >	         edeny = numpy.array(s1.sfield[0:nx], copy=True)
							      >	         pc.showSimple(["EDENSITY","Electron Density"],[edenx
         graf1.dscaler1(s1.sfield,' EDENSITY',ntime,999,0,nx,	         graf1.dscaler1(s1.sfield,' EDENSITY',ntime,999,0,nx,
         if (irc[0]==1):					         if (irc[0]==1):
            break						            break
         irc[0] = 0						         irc[0] = 0

# deposit ion charge with OpenMP: updates qi			# deposit ion charge with OpenMP: updates qi
   if (in1.movion==1):						   if (in1.movion==1):
      dtimer(dtime,itime,-1)					      dtimer(dtime,itime,-1)
      s1.qi.fill(0.0)						      s1.qi.fill(0.0)
      dtimer(dtime,itime,1)					      dtimer(dtime,itime,1)
      s1.tdpost[0] += float(dtime)				      s1.tdpost[0] += float(dtime)
      mpush1.mpost1(s1.pparti,s1.qi,s1.kipic,in1.qmi,s1.tdpos |	      mpush1.mpost1(sb1.pparti,s1.qi,sb1.kipic,in1.qmi,s1.tdp
# add guard cells: updates qi					# add guard cells: updates qi
      mgard1.maguard1(s1.qi,s1.tguard,nx)			      mgard1.maguard1(s1.qi,s1.tguard,nx)

# ion density diagnostic: updates sfield, pkwdi, wkdi		# ion density diagnostic: updates sfield, pkwdi, wkdi
   if (in1.movion==1):						   if (in1.movion==1):
      if (in1.ntdi > 0):					      if (in1.ntdi > 0):
         it = int(ntime/in1.ntdi)				         it = int(ntime/in1.ntdi)
         if (ntime==in1.ntdi*it):				         if (ntime==in1.ntdi*it):
            s1.idensity_diag1(s1.sfield,s1.pkwdi,s1.wkdi,ntim	            s1.idensity_diag1(s1.sfield,s1.pkwdi,s1.wkdi,ntim
            if ((in1.nddi==1) or (in1.nddi==3)):		            if ((in1.nddi==1) or (in1.nddi==3)):
# display smoothed ion density					# display smoothed ion density
							      >	               edenx = numpy.array(range(nx))
							      >	               pc.showSimple(["IDENSITY","Ion Density", "Elec
               graf1.dscaler1(s1.sfield,' ION DENSITY',ntime,	               graf1.dscaler1(s1.sfield,' ION DENSITY',ntime,
                              irc)				                              irc)
               if (irc[0]==1):					               if (irc[0]==1):
                  break						                  break
               irc[0] = 0					               irc[0] = 0
# ion spectral analysis						# ion spectral analysis
            if ((in1.nddi==2) or (in1.nddi==3)):		            if ((in1.nddi==2) or (in1.nddi==3)):
# display frequency spectrum					# display frequency spectrum
							      >	               pc.showSimpleImage("ION DENSITY OMEGA VS MODE+
							      >	               pc.showSimpleImage("ION DENSITY OMEGA VS MODE-
							      >	               wax = numpy.array(range(in1.modesxdi))
							      >	               pc.showSimple(["ION DENSITY OMEGA VS MODE LINE
               graf1.dmscaler1(s1.wkdi,'ION DENSITY OMEGA VS 	               graf1.dmscaler1(s1.wkdi,'ION DENSITY OMEGA VS 
                               ntime,999,1,in1.modesxdi,s1.cw	                               ntime,999,1,in1.modesxdi,s1.cw
               if (irc[0]==1):					               if (irc[0]==1):
                     break					                     break
               irc[0] = 0					               irc[0] = 0

# add electron and ion densities: updates qe			# add electron and ion densities: updates qe
   mfield1.maddqei1(s1.qe,s1.qi,s1.tfield,nx)			   mfield1.maddqei1(s1.qe,s1.qi,s1.tfield,nx)

# add electron and ion current densities: updates cue		# add electron and ion current densities: updates cue
   if (in1.movion==1):						   if (in1.movion==1):
      mfield1.maddcuei1(sb1.cue,sb1.cui,sb1.tfield,nx)		      mfield1.maddcuei1(sb1.cue,sb1.cui,sb1.tfield,nx)

# transform charge to fourier space: updates qe			# transform charge to fourier space: updates qe
   isign = -1							   isign = -1
   mfft1.mfft1r(s1.qe,isign,s1.mixup,s1.sct,s1.tfft,in1.indx)	   mfft1.mfft1r(s1.qe,isign,s1.mixup,s1.sct,s1.tfft,in1.indx)

# calculate longitudinal force/charge in fourier space:		# calculate longitudinal force/charge in fourier space:
# updates fxe, we						# updates fxe, we
   mfield1.mpois1(s1.qe,s1.fxe,s1.ffc,s1.we,s1.tfield,nx)	   mfield1.mpois1(s1.qe,s1.fxe,s1.ffc,s1.we,s1.tfield,nx)

# transform longitudinal electric force to real space: update	# transform longitudinal electric force to real space: update
   isign = 1							   isign = 1
   mfft1.mfft1r(s1.fxe,isign,s1.mixup,s1.sct,s1.tfft,in1.indx	   mfft1.mfft1r(s1.fxe,isign,s1.mixup,s1.sct,s1.tfft,in1.indx

# copy guard cells: updates fxe				      |	# transform current to fourier space: updates cue
							      >	   isign = -1
							      >	   mfft1.mfft1rn(sb1.cue,isign,s1.mixup,s1.sct,s1.tfft,in1.in
							      >
							      >	# calculate magnetic field in fourier space: updates byze, wb
							      >	   mfield1.mbbpois1(sb1.cue,sb1.byze,s1.ffc,in1.ci,sb1.wb,s1.
							      >
							      >	# transform magnetic force to real space: updates byze
							      >	   isign = 1
							      >	   mfft1.mfft1rn(sb1.byze,isign,s1.mixup,s1.sct,s1.tfft,in1.i
							      >
							      >	# add constant to magnetic field: updates byze
							      >	   mfield1.mbaddext1(sb1.byze,sb1.tfield,in1.omy,in1.omz,nx)
							      >
							      >	# copy guard cells: updates fxe, byze
   mgard1.mdguard1(s1.fxe,s1.tguard,nx)				   mgard1.mdguard1(s1.fxe,s1.tguard,nx)
							      >	   mgard1.mcguard1(sb1.byze,sb1.tguard,nx)

# initialize electron deposit data			      |	# add longitudinal and old transverse electric fields: update
							      >	   mfield1.maddvrfield1(sd1.exyze,sd1.cus,s1.fxe,sd1.tfield)
							      >
							      >	# deposit electron acceleration density and momentum flux wit
							      >	# updates dcu, amu
   dtimer(dtime,itime,-1)					   dtimer(dtime,itime,-1)
   sd1.dcu.fill(0.0); sd1.amu.fill(0.0)				   sd1.dcu.fill(0.0); sd1.amu.fill(0.0)
   dtimer(dtime,itime,1)					   dtimer(dtime,itime,1)
   sd1.tdcjpost[0] += float(dtime)				   sd1.tdcjpost[0] += float(dtime)
# initialize ion deposit data				      |	   mdpush1.wmgdjpost1(sb1.ppart,sd1.exyze,sb1.byze,sd1.dcu,sd
							      >	                      sb1.kpic,in1.omx,in1.qme,s1.qbme,in1.dt
							      >	                      sd1.tdcjpost,nx,in1.mx,in1.relativity)
							      >	                      
							      >	# deposit ion acceleration density and momentum flux with Ope
							      >	# updates dcui, amui
   if (in1.movion==1):						   if (in1.movion==1):
      dtimer(dtime,itime,-1)					      dtimer(dtime,itime,-1)
      sd1.dcui.fill(0.0); sd1.amui.fill(0.0)			      sd1.dcui.fill(0.0); sd1.amui.fill(0.0)
      dtimer(dtime,itime,1)					      dtimer(dtime,itime,1)
      sd1.tdcjpost[0] += float(dtime)				      sd1.tdcjpost[0] += float(dtime)
# predictor for darwin iteration: updates: cue, cus, byze, fx |	      mdpush1.wmgdjpost1(sb1.pparti,sd1.exyze,sb1.byze,sd1.dc
   sd1.darwin_predictor13(sd1.q2m0)			      |	                         sd1.amui,sb1.kipic,in1.omx,in1.qmi,s
							      >	                         in1.dt,in1.ci,sd1.tdcjpost,nx,in1.mx
							      >	                         in1.relativity)
							      >	# add electron and ion densities: updates dcu, amu
							      >	      mfield1.maddcuei1(sd1.dcu,sd1.dcui,sd1.tfield,nxe)
							      >	      mfield1.maddcuei1(sd1.amu,sd1.amui,sd1.tfield,nxe)
							      >
							      >	# add old scaled electric field: updates dcu
							      >	   mdpush1.mascfguard1(sd1.dcu,sd1.cus,q2m0,sd1.tdcjpost,nx)
							      >
							      >	# add guard cells: updates dcu, amu
							      >	   mgard1.macguard1(sd1.dcu,sd1.tguard,nx)
							      >	   mgard1.macguard1(sd1.amu,sd1.tguard,nx)
							      >
							      >	# transform acceleration density and momentum flux to fourier
							      >	# updates dcu, amu
							      >	   isign = -1
							      >	   mfft1.mfft1rn(sd1.dcu,isign,s1.mixup,s1.sct,s1.tfft,in1.in
							      >	   mfft1.mfft1rn(sd1.amu,isign,s1.mixup,s1.sct,s1.tfft,in1.in
							      >
							      >	# take transverse part of time derivative of current: updates
							      >	   mfield1.madcuperp1(sd1.dcu,sd1.amu,sd1.tfield,nx)
							      >
							      >	# calculate transverse electric field: updates cus, wf
							      >	   mfield1.mepois1(sd1.dcu,sd1.cus,sd1.ffe,s1.affp,in1.ci,sb1
							      >	                   sd1.tfield,nx)
							      >
							      >	# transform transverse electric field to real space: updates 
							      >	   isign = 1
							      >	   mfft1.mfft1rn(sd1.cus,isign,s1.mixup,s1.sct,s1.tfft,in1.in
							      >
							      >	# copy guard cells: updates cus
							      >	   mgard1.mcguard1(sd1.cus,sd1.tguard,nx)
							      >
							      >	# add longitudinal and transverse electric fields:
							      >	# exyze = cus + fxe, updates exyze
							      >	# cus needs to be retained for next time step
							      >	   mfield1.maddvrfield1(sd1.exyze,sd1.cus,s1.fxe,sd1.tfield)

# inner iteration loop						# inner iteration loop
   for k in xrange(0,in1.ndc):					   for k in xrange(0,in1.ndc):

# initialize electron deposit data				# initialize electron deposit data
      dtimer(dtime,itime,-1)					      dtimer(dtime,itime,-1)
      sb1.cue.fill(0.0); sd1.dcu.fill(0.0); sd1.amu.fill(0.0)	      sb1.cue.fill(0.0); sd1.dcu.fill(0.0); sd1.amu.fill(0.0)
      dtimer(dtime,itime,1)					      dtimer(dtime,itime,1)
      sd1.tdcjpost[0] += float(dtime)				      sd1.tdcjpost[0] += float(dtime)
# initialize ion deposit data					# initialize ion deposit data
      if (in1.movion==1):					      if (in1.movion==1):
         dtimer(dtime,itime,-1)					         dtimer(dtime,itime,-1)
         sb1.cui.fill(0.0); sd1.dcui.fill(0.0); sd1.amui.fill	         sb1.cui.fill(0.0); sd1.dcui.fill(0.0); sd1.amui.fill
         dtimer(dtime,itime,1)					         dtimer(dtime,itime,1)
         sd1.tdcjpost[0] += float(dtime)			         sd1.tdcjpost[0] += float(dtime)
# updates: dcu, cus, byze, fxyze			      |	# updates: dcu, cus, byze, exyze
      sd1.darwin_iteration(sd1.q2m0)			      |	      sd1.darwin_iteration(q2m0)

   pass								   pass

# add external traveling wave field			      <
   ts = in1.dt*float(ntime)				      <
   mfield1.meaddext13(sb1.fxyze,sb1.tfield,in1.amodex,in1.fre <
                      in1.trmp,in1.toff,in1.el0,in1.er0,nx)   <
							      <
# copy guard cells: updates fxyze			      <
   mgard1.mcguard1(sb1.fxyze,sb1.tguard,nx)		      <
							      <
# ion current density diagnostic: updates vfield, vpkwji, vwk	# ion current density diagnostic: updates vfield, vpkwji, vwk
   if (in1.movion==1):						   if (in1.movion==1):
      if (in1.ntji > 0):					      if (in1.ntji > 0):
         it = ntime/in1.ntji					         it = ntime/in1.ntji
         if (ntime==in1.ntji*it):				         if (ntime==in1.ntji*it):
            sb1.icurrent_diag13(sb1.vfield,sb1.vpkwji,sb1.vwk	            sb1.icurrent_diag13(sb1.vfield,sb1.vpkwji,sb1.vwk
            if ((in1.ndji==1) or (in1.ndji==3)):		            if ((in1.ndji==1) or (in1.ndji==3)):
# display smoothed ion current					# display smoothed ion current
							      >	               edenx = numpy.array(range(nx))
							      >	               pc.showSimple(["ICURRENTD","Y", "Z"],[edenx, e
               graf1.dvector1(sb1.vfield,' ION CURRENT',ntime	               graf1.dvector1(sb1.vfield,' ION CURRENT',ntime
                              nx,irc)				                              nx,irc)
               if (irc[0]==1):					               if (irc[0]==1):
                  break						                  break
               irc[0] = 0					               irc[0] = 0
# ion spectral analysis						# ion spectral analysis
            if ((in1.ndji==2) or (in1.ndji==3)):		            if ((in1.ndji==2) or (in1.ndji==3)):
# display frequency spectrum					# display frequency spectrum
							      >	               pc.showSimpleImage("ION CURRENT OMEGA VS MODEY
							      >	               pc.showSimpleImage("ION CURRENT OMEGA VS MODEY
							      >	               pc.showSimpleImage("ION CURRENT OMEGA VS MODEZ
							      >	               pc.showSimpleImage("ION CURRENT OMEGA VS MODEZ
               graf1.dmvector1(sb1.vwkji,'ION CURRENT OMEGA V	               graf1.dmvector1(sb1.vwkji,'ION CURRENT OMEGA V
                               ntime,999,2,2,in1.modesxji,s1.	                               ntime,999,2,2,in1.modesxji,s1.
               if (irc[0]==1):					               if (irc[0]==1):
                     break					                     break
               irc[0] = 0					               irc[0] = 0

# potential diagnostic: updates sfield, pkw, wk			# potential diagnostic: updates sfield, pkw, wk
   if (in1.ntp > 0):						   if (in1.ntp > 0):
      it = int(ntime/in1.ntp)					      it = int(ntime/in1.ntp)
      if (ntime==in1.ntp*it):					      if (ntime==in1.ntp*it):
         s1.potential_diag1(s1.sfield,s1.pkw,s1.wk,ntime)	         s1.potential_diag1(s1.sfield,s1.pkw,s1.wk,ntime)
         if ((in1.ndp==1) or (in1.ndp==3)):			         if ((in1.ndp==1) or (in1.ndp==3)):
# display potential						# display potential
							      >	            edenx = numpy.array(range(nx))
							      >	            pc.showSimple(["DRAWPOT","Potential"],[edenx],[s1
            graf1.dscaler1(s1.sfield,' POTENTIAL',ntime,999,0	            graf1.dscaler1(s1.sfield,' POTENTIAL',ntime,999,0
            if (irc[0]==1):					            if (irc[0]==1):
               break						               break
            irc[0] = 0						            irc[0] = 0
# spectral analysis						# spectral analysis
         if ((in1.ndp==2) or (in1.ndp==3)):			         if ((in1.ndp==2) or (in1.ndp==3)):
# display frequency spectrum					# display frequency spectrum
							      >	            pc.showSimpleImage("POTENTIAL OMEGA VS MODE+",s1.
							      >	            pc.showSimpleImage("POTENTIAL OMEGA VS MODE-",s1.
							      >	            wax = numpy.array(range(in1.modesxp))
							      >	            pc.showSimple(["POTENTIAL OMEGA VS MODE LINE","+O
            graf1.dmscaler1(s1.wk,'POTENTIAL OMEGA VS MODE',n	            graf1.dmscaler1(s1.wk,'POTENTIAL OMEGA VS MODE',n
                            in1.modesxp,s1.cwk,irc)		                            in1.modesxp,s1.cwk,irc)
            if (irc[0]==1):					            if (irc[0]==1):
               break						               break
            irc[0] = 0						            irc[0] = 0

# longitudinal efield diagnostic: updates sfield		# longitudinal efield diagnostic: updates sfield
   if (in1.ntel > 0):						   if (in1.ntel > 0):
      it = int(ntime/in1.ntel)					      it = int(ntime/in1.ntel)
      if (ntime==in1.ntel*it):					      if (ntime==in1.ntel*it):
         s1.elfield_diag1(s1.sfield)				         s1.elfield_diag1(s1.sfield)
# display longitudinal efield					# display longitudinal efield
							      >	         try:
							      >	            edenx
							      >	         except:
							      >	            edenx = numpy.array(range(nx))
							      >	         pc.showSimple(["ELFIELD","Longitudinal E-Field"],[ed
         graf1.dscaler1(s1.sfield,' ELFIELD',ntime,999,0,nx,i	         graf1.dscaler1(s1.sfield,' ELFIELD',ntime,999,0,nx,i
         if (irc[0]==1):					         if (irc[0]==1):
            break						            break
         irc[0] = 0						         irc[0] = 0

# vector potential diagnostic: updates vfield, vpkw, vwk	# vector potential diagnostic: updates vfield, vpkw, vwk
   if (in1.nta > 0):						   if (in1.nta > 0):
      it = ntime/in1.nta					      it = ntime/in1.nta
      if (ntime==in1.nta*it):					      if (ntime==in1.nta*it):
         sd1.vdpotential_diag13(sd1.vfield,sd1.vpkw,sd1.vwk,n	         sd1.vdpotential_diag13(sd1.vfield,sd1.vpkw,sd1.vwk,n
         if ((in1.nda==1) or (in1.nda==3)):			         if ((in1.nda==1) or (in1.nda==3)):
# display vector potential					# display vector potential
							      >	            try:
							      >	               edenx
							      >	            except:
							      >	               edenx = numpy.array(range(nx))
							      >	            pc.showSimple(["VECPOTENTIAL","y","z"],[edenx,ede
            graf1.dvector1(sd1.vfield,' VECTOR POTENTIAL',nti	            graf1.dvector1(sd1.vfield,' VECTOR POTENTIAL',nti
                           nx,irc)				                           nx,irc)
            if (irc[0]==1):					            if (irc[0]==1):
               break						               break
            irc[0] = 0						            irc[0] = 0
# spectral analysis						# spectral analysis
         if ((in1.nda==2) or (in1.nda==3)):			         if ((in1.nda==2) or (in1.nda==3)):
# display frequency spectrum					# display frequency spectrum
							      >	            pc.showSimpleImage("VECTOR POTENTIAL OMEGA VS MOD
							      >	            pc.showSimpleImage("VECTOR POTENTIAL OMEGA VS MOD
							      >	            pc.showSimpleImage("VECTOR POTENTIAL OMEGA VS MOD
							      >	            pc.showSimpleImage("VECTOR POTENTIAL OMEGA VS MOD
							      >
							      >	            wax = numpy.array(range(in1.modesxa))
							      >	            pc.showSimple(["VECTOR POTENTIAL OMEGA VS MODE Y 
							      >	            pc.showSimple(["VECTOR POTENTIAL OMEGA VS MODE Z 
            graf1.dmvector1(sd1.vwk,'VECTOR POTENTIAL OMEGA V	            graf1.dmvector1(sd1.vwk,'VECTOR POTENTIAL OMEGA V
                            ntime,999,2,2,in1.modesxa,s1.cwk,	                            ntime,999,2,2,in1.modesxa,s1.cwk,
            if (irc[0]==1):					            if (irc[0]==1):
               break						               break
            irc[0] = 0						            irc[0] = 0

# transverse efield diagnostic: updates vfield, vpkwet, vwket	# transverse efield diagnostic: updates vfield, vpkwet, vwket
   if (in1.ntet > 0):						   if (in1.ntet > 0):
      it = ntime/in1.ntet					      it = ntime/in1.ntet
      if (ntime==in1.ntet*it):					      if (ntime==in1.ntet*it):
         sd1.detfield_diag13(sd1.vfield,sd1.vpkwet,sd1.vwket,	         sd1.detfield_diag13(sd1.vfield,sd1.vpkwet,sd1.vwket,
         if ((in1.ndet==1) or (in1.ndet==3)):			         if ((in1.ndet==1) or (in1.ndet==3)):
# display transverse efield					# display transverse efield
							      >	            try:
							      >	               edenx
							      >	            except:
							      >	               edenx = numpy.array(range(nx))
							      >	            pc.showSimple(["TRANSVERSE E FIELD","Y","Z"],[ede
            graf1.dvector1(sd1.vfield,' TRANSVERSE EFIELD',nt	            graf1.dvector1(sd1.vfield,' TRANSVERSE EFIELD',nt
                           2,nx,irc)				                           2,nx,irc)
            if (irc[0]==1):					            if (irc[0]==1):
               break						               break
            irc[0] = 0						            irc[0] = 0
# spectral analysis						# spectral analysis
         if ((in1.ndet==2) or (in1.ndet==3)):			         if ((in1.ndet==2) or (in1.ndet==3)):
# display frequency spectrum					# display frequency spectrum
							      >	            pc.showSimpleImage("FT TRANSVERSE E.F. Y +OMEGA V
							      >	            pc.showSimpleImage("FT TRANSVERSE E.F. Y -OMEGA V
							      >	            pc.showSimpleImage("FT TRANSVERSE E.F. Z +OMEGA V
							      >	            pc.showSimpleImage("FT TRANSVERSE E.F. Z -OMEGA V
							      >
							      >	            wax = numpy.array(range(in1.modesxet))
							      >	            pc.showSimple(["TRANSVERSE E.F. Y OMEGA VS MODE",
							      >	            pc.showSimple(["TRANSVERSE E.F. Z OMEGA VS MODE",
            graf1.dmvector1(sd1.vwket,'TRANSVERSE EFIELD OMEG	            graf1.dmvector1(sd1.vwket,'TRANSVERSE EFIELD OMEG
                            ntime,999,2,2,in1.modesxet,s1.cwk	                            ntime,999,2,2,in1.modesxet,s1.cwk
            if (irc[0]==1):					            if (irc[0]==1):
               break						               break
            irc[0] = 0						            irc[0] = 0

# magnetic field diagnostic: updates vfield			# magnetic field diagnostic: updates vfield
   if (in1.ntb > 0):						   if (in1.ntb > 0):
      it = ntime/in1.ntb					      it = ntime/in1.ntb
      if (ntime==in1.ntb*it):					      if (ntime==in1.ntb*it):
         sd1.dbfield_diag13(sd1.vfield)				         sd1.dbfield_diag13(sd1.vfield)
# display magnetic field					# display magnetic field
							      >	         try:
							      >	            edenx
							      >	         except:
							      >	            edenx = numpy.array(range(nx))
							      >	         pc.showSimple(["BFIELD","Y","Z"],[edenx,edenx],[ sd1
         graf1.dvector1(sd1.vfield,' MAGNETIC FIELD',ntime,99	         graf1.dvector1(sd1.vfield,' MAGNETIC FIELD',ntime,99
                        irc)					                        irc)
         if (irc[0]==1):					         if (irc[0]==1):
            break						            break
         irc[0] = 0						         irc[0] = 0

# velocity diagnostic						# velocity diagnostic
   if (in1.ntv > 0):						   if (in1.ntv > 0):
      it = int(ntime/in1.ntv)					      it = int(ntime/in1.ntv)
      if (ntime==in1.ntv*it):					      if (ntime==in1.ntv*it):
# updates ppart, kpic, fv, fvm, fvtm				# updates ppart, kpic, fv, fvm, fvtm
         sb1.evelocity_diag13(s1.ppart,s1.kpic,s1.fv,s1.fvm,s |	         sb1.evelocity_diag13(sb1.ppart,sb1.kpic,sb1.fv,sb1.f
							      >	                              sb1.fvtm)
# display electron velocity distributions			# display electron velocity distributions
         if ((in1.ndv==1) or (in1.ndv==3)):			         if ((in1.ndv==1) or (in1.ndv==3)):
            graf1.displayfv1(s1.fv,s1.fvm,' ELECTRON',ntime,i |	            pc.showVelocity(sb1.fv[:,:], ["x","y","z"], fvm=s
							      >	            graf1.displayfv1(sb1.fv,sb1.fvm,' ELECTRON',ntime
                             irc)				                             irc)
            if (irc[0]==1):					            if (irc[0]==1):
               break						               break
            irc[0] = 0						            irc[0] = 0
# ion distribution function					# ion distribution function
         if (in1.movion==1):					         if (in1.movion==1):
# updates pparti, kipic, fvi, fvmi, fvtmi			# updates pparti, kipic, fvi, fvmi, fvtmi
            sb1.ivelocity_diag13(s1.pparti,s1.kipic,s1.fvi,s1 |	            sb1.ivelocity_diag13(sb1.pparti,sb1.kipic,sb1.fvi
                                 s1.fvtmi)		      |	                                 sb1.fvtmi)
# display ion velocity distributions				# display ion velocity distributions
            if ((in1.ndv==2) or (in1.ndv==3)):			            if ((in1.ndv==2) or (in1.ndv==3)):
               graf1.displayfv1(s1.fvi,s1.fvmi,' ION',ntime,i |	               pc.showVelocity(sb1.fvi[:,:], ["x","y","z"], f
                                irc)			      |	               graf1.displayfv1(sb1.fvi,sb1.fvmi,' ION',ntime
							      >	                             irc)
               if (irc[0]==1):					               if (irc[0]==1):
                  break						                  break
               irc[0] = 0					               irc[0] = 0

# trajectory diagnostic: updates ppart, kpic, partd, fvtp, fv	# trajectory diagnostic: updates ppart, kpic, partd, fvtp, fv
   if (in1.ntt > 0):						   if (in1.ntt > 0):
      it = int(ntime/in1.ntt)					      it = int(ntime/in1.ntt)
      if (ntime==in1.ntt*it):					      if (ntime==in1.ntt*it):
         sb1.traj_diag13(s1.ppart,s1.kpic,s1.partd,s1.fvtp,s1 |	         sb1.traj_diag13(sb1.ppart,sb1.kpic,sb1.partd,sb1.fvt
							      >	                         sb1.fvmtp)
         if (in1.nst==3):					         if (in1.nst==3):
# display velocity distributions				# display velocity distributions
            graf1.displayfv1(s1.fvtp,s1.fvmtp,' ELECTRON',nti |	            graf1.displayfv1(sb1.fvtp,sb1.fvmtp,' ELECTRON',n
                             2,irc)			      |	                             in1.nmv,2,irc)
            if (irc[0]==1):					            if (irc[0]==1):
               break						               break
            irc[0] = 0						            irc[0] = 0

# phase space diagnostic					# phase space diagnostic
   if (in1.nts > 0):						   if (in1.nts > 0):
      it = int(ntime/in1.nts)					      it = int(ntime/in1.nts)
      if (ntime==in1.nts*it):					      if (ntime==in1.nts*it):
# plot electrons						# plot electrons
         if ((in1.nds==1) or (in1.nds==3)):			         if ((in1.nds==1) or (in1.nds==3)):
# vx, vy, or vz versus x					# vx, vy, or vz versus x
            nn = in1.nsxv; ierr[0] = 0				            nn = in1.nsxv; ierr[0] = 0
            for i in xrange(0,3):				            for i in xrange(0,3):
               if ((nn % 2)==1):				               if ((nn % 2)==1):
                  graf1.dpmgrasp1(s1.ppart,s1.kpic,' ELECTRON |	                  a,b,c = numpy.shape(sb1.ppart)
							      >	                  phasearr = numpy.empty( (2,b,c), dtype=sb1.
							      >	                  phasearr[1,:,:] = sb1.ppart[i+2-1,:,:]
							      >	                  phasearr[0,:,:] = sb1.ppart[1-1,:,:]
							      >	                  pc.showPhase(phasearr, sb1.kpic, plottype="
							      >	                  graf1.dpmgrasp1(sb1.ppart,sb1.kpic,' ELECTR
                                  999,nx,i+2,1,in1.ntsc,irc)	                                  999,nx,i+2,1,in1.ntsc,irc)
                  if (irc[0]==1):				                  if (irc[0]==1):
                     ierr[0] = 1				                     ierr[0] = 1
							      >	                     print "break"
                     break					                     break
                  irc[0] = 0					                  irc[0] = 0
               nn = int(nn/2)					               nn = int(nn/2)
            if (ierr[0]==1):					            if (ierr[0]==1):
               break						               break
# vx-vy, vx-vz or vy-vz						# vx-vy, vx-vz or vy-vz
            nn = in1.nsvv; ierr[0] = 0				            nn = in1.nsvv; ierr[0] = 0
            for i in xrange(0,3):				            for i in xrange(0,3):
               if ((nn % 2)==1):				               if ((nn % 2)==1):
                  graf1.dpmgrasp1(s1.ppart,s1.kpic,' ELECTRON |	                  a,b,c = numpy.shape(sb1.ppart)
							      >	                  phasearr = numpy.empty( (2,b,c), dtype=sb1.
							      >	                  phasearr[1,:,:] = sb1.ppart[min(i+3,4)-1,:,
							      >	                  phasearr[0,:,:] = sb1.ppart[max(i+1,2)-1,:,
							      >	                  pc.showPhase(phasearr, sb1.kpic, plottype="
							      >	                  graf1.dpmgrasp1(sb1.ppart,sb1.kpic,' ELECTR
                                  999,nx,min(i+3,4),max(i+1,2	                                  999,nx,min(i+3,4),max(i+1,2
                                  irc)				                                  irc)
                  if (irc[0]==1):				                  if (irc[0]==1):
                     ierr[0] = 1				                     ierr[0] = 1
                     break					                     break
                  irc[0] = 0					                  irc[0] = 0
               nn = int(nn/2)					               nn = int(nn/2)
            if (ierr[0]==1):					            if (ierr[0]==1):
               break						               break
# ion phase space						# ion phase space
         if (in1.movion==1):					         if (in1.movion==1):
# plot ions							# plot ions
            if ((in1.nds==2) or (in1.nds==3)):			            if ((in1.nds==2) or (in1.nds==3)):
# vx, vy, or vz versus x					# vx, vy, or vz versus x
               nn = in1.nsxv; ierr[0] = 0			               nn = in1.nsxv; ierr[0] = 0
               for i in xrange(0,3):				               for i in xrange(0,3):
                  if ((nn % 2)==1):				                  if ((nn % 2)==1):
                     graf1.dpmgrasp1(s1.pparti,s1.kipic,' ION |	                     a,b,c = numpy.shape(sb1.pparti)
							      >	                     phasearr = numpy.empty( (2,b,c), dtype=s
							      >	                     phasearr[1,:,:] = sb1.pparti[i+2-1,:,:]
							      >	                     phasearr[0,:,:] = sb1.pparti[1-1,:,:]
							      >	                     pc.showPhase(phasearr, sb1.kipic, plotty
							      >	                     graf1.dpmgrasp1(sb1.pparti,sb1.kipic,' I
                                     999,nx,i+2,1,in1.ntsc,ir	                                     999,nx,i+2,1,in1.ntsc,ir
                     if (irc[0]==1):				                     if (irc[0]==1):
                        ierr[0] = 1				                        ierr[0] = 1
                        break					                        break
                     irc[0] = 0					                     irc[0] = 0
                  nn = int(nn/2)				                  nn = int(nn/2)
               if (ierr[0]==1):					               if (ierr[0]==1):
                  break						                  break
# vx-vy, vx-vz or vy-vz						# vx-vy, vx-vz or vy-vz
               nn = in1.nsvv; ierr[0] = 0			               nn = in1.nsvv; ierr[0] = 0
               for i in xrange(0,3):				               for i in xrange(0,3):
                  if ((nn % 2)==1):				                  if ((nn % 2)==1):
                     graf1.dpmgrasp1(s1.pparti,s1.kipic,' ION |	                     a,b,c = numpy.shape(sb1.pparti)
							      >	                     phasearr = numpy.empty( (2,b,c), dtype=s
							      >	                     phasearr[1,:,:] = sb1.pparti[min(i+3,4)-
							      >	                     phasearr[0,:,:] = sb1.pparti[max(i+1,2)-
							      >	                     pc.showPhase(phasearr, sb1.kipic, plotty
							      >	                     graf1.dpmgrasp1(sb1.pparti,sb1.kipic,' I
                                     999,nx,min(i+3,4),max(i+	                                     999,nx,min(i+3,4),max(i+
                                     in1.ntsc,irc)		                                     in1.ntsc,irc)
                     if (irc[0]==1):				                     if (irc[0]==1):
                        ierr[0] = 1				                        ierr[0] = 1
                        break					                        break
                     irc[0] = 0					                     irc[0] = 0
                  nn = int(nn/2)				                  nn = int(nn/2)
               if (ierr[0]==1):					               if (ierr[0]==1):
                  break						                  break

# push electrons with OpenMP: updates ppart, wke, kpic		# push electrons with OpenMP: updates ppart, wke, kpic
   sd1.dpush_electrons13(s1.ppart,s1.kpic)		      |	   sd1.dpush_electrons13(sb1.ppart,sb1.kpic)

# push ions with OpenMP: updates pparti, wki, kipic		# push ions with OpenMP: updates pparti, wki, kipic
   if (in1.movion==1):						   if (in1.movion==1):
      sd1.dpush_ions13(s1.pparti,s1.kipic)		      |	      sd1.dpush_ions13(sb1.pparti,sb1.kipic)

# start running simulation backwards:				# start running simulation backwards:
# need to reverse time lag in leap-frog integration scheme	# need to reverse time lag in leap-frog integration scheme
   if (in1.treverse==1):					   if (in1.treverse==1):
      if (((ntime+1)==(nloop/2)) or ((ntime+1)==nloop)):	      if (((ntime+1)==(nloop/2)) or ((ntime+1)==nloop)):
         sd1.d_time_reverse1()					         sd1.d_time_reverse1()

# energy diagnostic						# energy diagnostic
   if (in1.ntw > 0):						   if (in1.ntw > 0):
      it = int(ntime/in1.ntw)					      it = int(ntime/in1.ntw)
      if (ntime==in1.ntw*it):					      if (ntime==in1.ntw*it):
         sd1.denergy_diag13(s1.wt,ntime,iuot)		      |	         pc.showEnergy(numpy.array(range(ntime))*in1.dt, sb1.
							      |	         sd1.denergy_diag13(sb1.wt,ntime,iuot)
# restart file						      <
   if (in1.ntr > 0):					      <
      n = ntime + 1					      <
      it = int(n/in1.ntr)				      <
      if (n==in1.ntr*it):				      <
         dtimer(dtime,itime,-1)				      <
         sd1.bwrite_drestart13(s1.iur,n)		      <
         sd1.dwrite_drestart13(s1.iur)			      <
         dtimer(dtime,itime,1)				      <
         s1.tfield[0] += float(dtime)			      <

ntime = ntime + 1						ntime = ntime + 1

# loop time							# loop time
dtimer(dtime,ltime,1)						dtimer(dtime,ltime,1)
tloop = tloop + float(dtime)					tloop = tloop + float(dtime)

# * * * end main iteration loop * * *				# * * * end main iteration loop * * *

print >> iuot							print >> iuot
print >> iuot,"ntime,relativity,ndc=",ntime,",",in1.relativit	print >> iuot,"ntime,relativity,ndc=",ntime,",",in1.relativit
if (in1.treverse==1):						if (in1.treverse==1):
   print >> iuot, "treverse = ", in1.treverse			   print >> iuot, "treverse = ", in1.treverse

# print timing summaries					# print timing summaries
sd1.print_dtimings13(tinit,tloop,iuot)				sd1.print_dtimings13(tinit,tloop,iuot)

if ((in1.ntw > 0) or (in1.ntt > 0)):				if ((in1.ntw > 0) or (in1.ntt > 0)):
   graf1.reset_graphs()						   graf1.reset_graphs()

# trajectory diagnostic						# trajectory diagnostic
if (in1.ntt > 0):						if (in1.ntt > 0):
   if ((in1.nst==1) or (in1.nst==2)):				   if ((in1.nst==1) or (in1.nst==2)):
      if (in1.nplot > 0):					      if (in1.nplot > 0):
         irc[0] = graf1.open_graphs(1)				         irc[0] = graf1.open_graphs(1)
      ts = in1.t0					      |	      ts = in1.t0 + in1.dt*float(in1.ntt)
      graf1.displaytr1(sb1.partd,ts,in1.dt*float(in1.ntt),sb1	      graf1.displaytr1(sb1.partd,ts,in1.dt*float(in1.ntt),sb1
                       irc)					                       irc)
      if (irc[0]==1):						      if (irc[0]==1):
         exit(0)						         exit(0)
      graf1.reset_nplot(in1.nplot,irc)				      graf1.reset_nplot(in1.nplot,irc)

# energy diagnostic						# energy diagnostic
if (in1.ntw > 0):						if (in1.ntw > 0):
   ts = in1.t0						      |	   ts = in1.t0 + in1.dt*float(in1.ntw)
# display energy histories					# display energy histories
   graf1.displayw1(s1.wt,ts,in1.dt*float(in1.ntw),s1.itw,irc) |	   graf1.displayw1(sb1.wt,ts,in1.dt*float(in1.ntw),sb1.itw,ir
   if (irc[0]==1):						   if (irc[0]==1):
      exit(0)							      exit(0)
# print energy summaries					# print energy summaries
   sb1.print_energy13(s1.wt,iuot)			      |	   sb1.print_energy13(sb1.wt,iuot)

# velocity diagnostic						# velocity diagnostic
if (in1.ntv > 0):						if (in1.ntv > 0):
   ts = in1.t0						      |	   ts = in1.t0 + in1.dt*float(in1.ntv)
   graf1.displayfvt1(s1.fvtm,' ELECTRON',ts,in1.dt*float(in1. |	   graf1.displayfvt1(sb1.fvtm,' ELECTRON',ts,in1.dt*float(in1
                     s1.itv,irc)			      |	                     sb1.itv,irc)
   if (irc[0]==1):						   if (irc[0]==1):
      exit(0)							      exit(0)
# ions								# ions
   if (in1.movion==1):						   if (in1.movion==1):
      graf1.displayfvt1(s1.fvtmi,' ION',ts,in1.dt*float(in1.n |	      graf1.displayfvt1(sb1.fvtmi,' ION',ts,in1.dt*float(in1.
                        s1.itv,irc)			      |	                        sb1.itv,irc)
      if (irc[0]==1):						      if (irc[0]==1):
         exit(0)						         exit(0)

# display final spectral analysis for ion density		# display final spectral analysis for ion density
if (in1.movion==1):						if (in1.movion==1):
   if (in1.ntdi > 0):						   if (in1.ntdi > 0):
      if ((in1.nddi==2) or (in1.nddi==3)):			      if ((in1.nddi==2) or (in1.nddi==3)):
# display frequency spectrum					# display frequency spectrum
         graf1.dmscaler1(s1.wkdi,'ION DENSITY OMEGA VS MODE',	         graf1.dmscaler1(s1.wkdi,'ION DENSITY OMEGA VS MODE',
                         1,in1.modesxdi,s1.cwk,irc)		                         1,in1.modesxdi,s1.cwk,irc)
         if (irc[0]==1):					         if (irc[0]==1):
            exit(0)						            exit(0)

# display final spectral analysis for potential			# display final spectral analysis for potential
if (in1.ntp > 0):						if (in1.ntp > 0):
   if ((in1.ndp==2) or (in1.ndp==3)):				   if ((in1.ndp==2) or (in1.ndp==3)):
# display frequency spectrum					# display frequency spectrum
      graf1.dmscaler1(s1.wk,'POTENTIAL OMEGA VS MODE',ntime,9	      graf1.dmscaler1(s1.wk,'POTENTIAL OMEGA VS MODE',ntime,9
                      in1.modesxp,s1.cwk,irc)			                      in1.modesxp,s1.cwk,irc)
      if (irc[0]==1):						      if (irc[0]==1):
         exit(0)						         exit(0)

# display final spectral analysis for ion current density	# display final spectral analysis for ion current density
if (in1.movion==1):						if (in1.movion==1):
   if (in1.ntji > 0):						   if (in1.ntji > 0):
      if ((in1.ndji==2) or (in1.ndji==3)):			      if ((in1.ndji==2) or (in1.ndji==3)):
# display frequency spectrum					# display frequency spectrum
         graf1.dmvector1(sb1.vwkji,'ION CURRENT OMEGA VS MODE	         graf1.dmvector1(sb1.vwkji,'ION CURRENT OMEGA VS MODE
                         999,2,2,in1.modesxji,s1.cwk,irc)	                         999,2,2,in1.modesxji,s1.cwk,irc)
         if (irc[0]==1):					         if (irc[0]==1):
            exit(0)						            exit(0)

# display final spectral analysis for vector potential		# display final spectral analysis for vector potential
if (in1.nta > 0):						if (in1.nta > 0):
   if ((in1.nda==2) or (in1.nda==3)):				   if ((in1.nda==2) or (in1.nda==3)):
# display frequency spectrum					# display frequency spectrum
      graf1.dmvector1(sd1.vwk,'VECTOR POTENTIAL OMEGA VS MODE	      graf1.dmvector1(sd1.vwk,'VECTOR POTENTIAL OMEGA VS MODE
                      999,2,2,in1.modesxa,s1.cwk,irc)		                      999,2,2,in1.modesxa,s1.cwk,irc)
      if (irc[0]==1):						      if (irc[0]==1):
         exit(0)						         exit(0)

# display final spectral analysis for transverse efield		# display final spectral analysis for transverse efield
if (in1.ntet > 0):						if (in1.ntet > 0):
   if ((in1.ndet==2) or (in1.ndet==3)):				   if ((in1.ndet==2) or (in1.ndet==3)):
# display frequency spectrum					# display frequency spectrum
      graf1.dmvector1(sd1.vwket,'TRANSVERSE EFIELD OMEGA VS M	      graf1.dmvector1(sd1.vwket,'TRANSVERSE EFIELD OMEGA VS M
                      999,2,2,in1.modesxet,s1.cwk,irc)		                      999,2,2,in1.modesxet,s1.cwk,irc)
      if (irc[0]==1):						      if (irc[0]==1):
         exit(0)						         exit(0)

# close diagnostics						# close diagnostics
sd1.close_ddiags13(s1.iudm)				      |	sd1.close_ddiags13(iudm)
# close reset and restart files: iur, iurr, iur0	      <
s1.close_restart1()					      <
# close output file						# close output file
print >> iuot, " * * * q.e.d. * * *"				print >> iuot, " * * * q.e.d. * * *"
iuot.close()							iuot.close()
# close graphics device						# close graphics device
graf1.close_graphs()						graf1.close_graphs()
